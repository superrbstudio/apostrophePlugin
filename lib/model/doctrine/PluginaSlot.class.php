<?php
/**
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * @package    apostrophePlugin
 * @subpackage    model
 * @author     P'unk Avenue <apostrophe@punkave.com>
 */
abstract class PluginaSlot extends BaseaSlot
{
  protected $editDefault = false;

  /**
   *
   * "Dear Doctrine: I know I did array hydration and then created an object and called
   * hydrate() on it and now you're confused, but trust me, I've got the properties
   * that matter. Cheers"
   */
  public function setClean()
  {
    $this->_state = Doctrine_Record::STATE_CLEAN;
  }
  
  /**
   * By default, the editor for a slot is accessed by double-clicking
   * on an outlined normal view of the slot. That's not appropriate
   * for some custom slot types. Say so by overriding this function
   * in your slot's model subclass and returning false. Then you'll
   * need to implement opening the editor yourself. You can do that
   * in your _normal_view.php by testing $editable and outputting
   * button_to("Edit", $showEditorJS) or similar if it is true.
   * showEditorJS contains ready-to-go jQuery code to hide the
   * normal view and display the editor view.
   * 
   * The return value of this method becomes the default setting of
   * the outline_editable option, which can still be overridden
   * manually.
   * @return mixed
   */
  public function isOutlineEditable()
  {
    return true;
  }

  /**
   * You should return a reasonable plaintext representation of your
   * slot's contents for search indexing purposes. A media slot
   * would return the title and description of its contents.
   * @return mixed
   */
  public function getSearchText()
  {
    return '';
  }

  /**
   * 
   * This function returns a plaintext representation of your slot's contents.
   * This differs from getSearchText in that it should only be used for slots
   * with user entered text.
   * @return string
   */
  public function getText()
  {
    return '';
  }

  /**
   * 
   * This function returns a basic HTML representation of your slot's comments
   * (passing the default settings of aHtml::simplify, for instance). Used for Google Calendar
   * buttons, RSS feeds and similar
   * @return string
   */
  public function getBasicHtml()
  {
    /* 
      If we don't expressly implement this, return the plaintext representation
      with entity escaping restored
    */
    return htmlentities($this->getText(), ENT_COMPAT, 'UTF-8');
  }

  /**
   * Conveniences for slots that use $this->value to store all of their state
   * and wish to store an array there.
   * @param mixed $default
   * @return mixed
   */
  public function getArrayValue($default = array())
  {
    if (strlen($this->value))
    {
      return unserialize($this->value);
    }
    return $default;
  }

  /**
   * DOCUMENT ME
   * @param mixed $value
   */
  public function setArrayValue($value)
  {
    if (!is_array($value))
    {
      throw new Exception("Argument is not an array in setArrayValue");
    }
    $this->value = serialize($value);
  }

  /**
   * Called on the current version of every slot by the a:refresh-slots task,
   * a periodic task used to update cached information that may be part of each slot's state
   * and which is subject to occasional change. Right now the best example is the use of
   * static URLs pointing directly to the media server for performance in
   * media slots. These need refreshing if the frontend controller name changes
   * as part of launch. Also media slots will clean up and remove references to
   * deleted media items when refresh is called.
   */
  public function refreshSlot()
  {
  }

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function editDefault()
  {
    return $this->editDefault;  
  }

  /**
   * DOCUMENT ME
   * @param mixed $editDefault
   */
  public function setEditDefault($editDefault)
  {
    $this->editDefault = $editDefault;
  }

  /**
   * Returns true if this slot should open the edit view immediately.
   * That's true if the slot is new and is designed to be edited immediately
   * when new
   * @return mixed
   */
  public function isOpen()
  {
    return $this->isNew() && $this->editDefault();
  }

  /**
   * You must pass the slot options in effect so that allowed_variants can be taken into account
   * @param mixed $options
   * @return mixed
   */
  public function getEffectiveVariant($options)
  {
    $variants = aTools::getVariantsForSlotType($this->type, $options);
    if (!isset($variants))
    {
      // No variants, no class
      return '';
    }
    // Treat null and an empty string the same
    $variant = $this->variant . '';
    // If the variant is not defined (and the empty string will not be),
    // and there is at least one variant, return the first one as the default.
    // If there are no variants return an empty string
    if (!isset($variants[$variant]))
    {
      if (count($variants))
      {
        // Return the first variant for the type, if any, when the variant is bogus
        $keys = array_keys($variants);
        return $keys[0];
      }
      return '';
    }
    // If the variant is valid, return it as the CSS class
    return $this->variant;
  }

  /**
   * We don't want to copy most of the references, but we do need
   * copies of the refClass objects for associated media. Otherwise
   * there is no meaningful version control for media slots. We can
   * create the copies implicitly by building up a new MediaItems list.
   * @param mixed $deep
   * @return mixed
   */
  public function copy($deep = false)
  {
    // We ignore the deep parameter (it's part of the signature of the method in
    // the base class), instead copying what is appropriate (links to media items) and not
    // things that are not our responsibility (actual media items)
    
    $new = parent::copy();
    // This could perhaps be a little faster - right now we're pulling in the
    // actual MediaItem objects, all we really need is their IDs. That's one join
    // more than strictly necessary
    $mediaItems = $this->MediaItems;
    $ids = array();
    foreach ($mediaItems as $mediaItem)
    {
      $ids[] = $mediaItem->id;
    }
    $new->link('MediaItems', $ids);
    return $new;
  }

  /**
   * Doctrine_Collection::contains doesn't really take a primary key as an argument as
   * you'd expect. Fortunately getPrimaryKeys is available
   * @param mixed $id
   * @return mixed
   */
  public function containsMediaItemId($id)
  {
    $idMap = array_flip($this->MediaItems->getPrimaryKeys());
    return isset($idMap[$id]);
  }

  /**
   * Get all media items, if any, associated with this slot, and return
   * them in the order specified by the getMediaItems() method. By default
   * there is no particular ordering and getMediaItems returns false, however
   * subclasses such as aSlideshowSlot have an implementation that returns
   * an array of media item IDs and this order is respected if present.
   * @return mixed
   */
  public function getOrderedMediaItems()
  {
    $order = $this->getMediaItemOrder();
    $items = $this->getMediaItems();
    if ($order)
    {
      $itemsById = aArray::listToHashById($items);
      $ordered = array();
      foreach ($order as $id)
      {
        if (isset($itemsById[$id]))
        {
          $ordered[] = $itemsById[$id];
        }
      }
      return $ordered;
    }

    return $items;
  }

  /**
   * If the media items associated with this slot (if any) have a particular order,
   * return an array of media item ids in the correct order. If media items are
   * irrelevant to the slot or there is no ordering to them, return false
   * (the default behavior). See PluginaSlideshowSlot for an implementation of
   * ordering.
   */

  public function getMediaItemOrder()
  {
    return false;
  }

}
