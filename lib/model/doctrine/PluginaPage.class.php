<?php
/**
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * @package    apostrophePlugin
 * @subpackage    model
 * @author     P'unk Avenue <apostrophe@punkave.com>
 */
abstract class PluginaPage extends BaseaPage
{
  const NEXT_PERMID = -1;
  public $culture;
  
  // Keep all cached information here for easy reference and inclusion 
  // in the reset code in hydrate()
  public $privilegesCache = null;
  protected $slotCache = false;
  protected $childrenCache = null;
  protected $childrenCacheLivingOnly = null;
  protected $childrenCacheSlot = null;
  protected $ancestorsCache = false;
  protected $parentCache = false;

  /**
   * DOCUMENT ME
   * @param array $data
   * @param mixed $overwriteLocalChanges
   * @return mixed
   */
  public function hydrate(array $data, $overwriteLocalChanges = true)
  {
    // Purge all caches when Doctrine refreshes the object
    $this->slotCache = false;
    $this->privilegesCache = array();
    $this->childrenCache = null;
    $this->childrenCacheLivingOnly = null;
    $this->childrenCacheSlot = null;
    $this->ancestorsCache = false;
    $this->parentCache = false;
    return parent::hydrate($data, $overwriteLocalChanges);
  }

  /**
   * Not a typo. Doctrine calls construct() for you as an alternative
   * to __construct(), which it won't let you override.
   */
  public function construct()
  {
    $this->culture = aTools::getUserCulture();
    $this->privilegesCache = array();
  }

  /**
   * DOCUMENT ME
   * @param mixed $message
   */
  protected function log($message)
  {
    sfContext::getInstance()->getLogger()->info("PAGE: $message");
  }

  /**
   * DOCUMENT ME
   * @param mixed $privilege
   * @param mixed $user
   * @return mixed
   */
  public function userHasPrivilege($privilege, $user = false)
  {
    return aPageTable::checkPrivilege($privilege, $this, $user);
  }

  /**
   * Returns all current slots as an array of arrays of arrays indexed by culture, then by area name, then by permid
   *
   * YOU MUST fetch the page with an appropriate query method such as retrieveBySlug(),
   * retrieveById, queryWithSlot or queryWithSlots, otherwise you will NOT get the 
   * right slots in the right order in the right culture for the right version. Especially
   * if your client is in the office for a demo
   *
   * @return array
   */
  public function getAllSlots()
  {
    return $this->slotCache;
  }

  /**
   * Returns the area names currently in use on the page for the current culture 
   * (note that this method doesn't know whether your template actually pulls them in or not).
   * Useful when paired with getSlotsByAreaName()
   *
   * YOU MUST fetch the page with an appropriate query method such as retrieveBySlug(),
   * retrieveById, queryWithSlot or queryWithSlots, otherwise you will NOT get the 
   * right slots in the right order in the right culture for the right version. Especially
   * if your client is in the office for a demo
   *
   * @return array
   */
  public function getAreaNames()
  {
    return array_keys($this->slotCache[$this->culture]);
  }

  /**
   * Checks whether a slot with the specified name and permid exists in the
   * page at present
   *
   * YOU MUST fetch the page with an appropriate query method such as retrieveBySlug(),
   * retrieveById, queryWithSlot or queryWithSlots, otherwise you will NOT get the 
   * right slots in the right order in the right culture for the right version. Especially
   * if your client is in the office for a demo
   * @param string $name
   * @param string $permid
   * @return boolean
   */
  public function hasSlot($name, $permid = 1)
  {
    $this->populateSlotCache();
    if (isset($this->slotCache[$this->culture][$name][$permid]))
    {
      return true;
    }
    return false;
  }

  /**
   * Returns the slot object with the specified name and permid if it exists in the page at present
   *
   * YOU MUST fetch the page with an appropriate query method such as retrieveBySlug(),
   * retrieveById, queryWithSlot or queryWithSlots, otherwise you will NOT get the 
   * right slots in the right order in the right culture for the right version. Especially
   * if your client is in the office for a demo
   * @param string $name
   * @param string $permid
   * @return object (or false)
   */
  public function getSlot($name, $permid = 1)
  {
    if ($this->hasSlot($name, $permid))
    {
      return $this->slotCache[$this->culture][$name][$permid];
    }
    return false;
  }

  /**
   * A bad, old name for getSlotsByAreaName(). Supported for bc 
   */
   
  public function getArea($name, $new = false, $newFirst = false)
  {
    return $this->getSlotsByAreaName($name, $new, $newFirst);
  }


  /**
   * $name is the area name. $new can be a slot class name, an already-created new
   * slot object, or false. If it is false no new slot is added to the list to be 
   * returned. If it is a class name the slot is constructed for you.
   * 
   * If $newFirst is true the new slot will be at the top of the area,
   * otherwise the bottom.
   *
   * YOU MUST fetch the page with an appropriate query method such as retrieveBySlug(),
   * retrieveById, queryWithSlot or queryWithSlots, otherwise you will NOT get the 
   * right slots in the right order in the right culture for the right version. Especially
   * if your client is in the office for a demo
   * 
   * @param string $name
   * @param mixed $new
   * @param boolean $newFirst
   * @return mixed
   */
  public function getSlotsByAreaName($name, $new = false, $newFirst = false)
  {
    $this->populateSlotCache();
    $results = array();
    if ($new)
    {
      $permidAndRank = $this->getNextPermidAndRank($name, $newFirst);
      if (!($new instanceof aSlot))
      {
        // It's a type name, make one
        $new = $this->createSlot($new);
      }
      else
      {
        // We passed one in
      }
    }
    if ($new && $newFirst)
    {
      $results[$permidAndRank['permid']] = $new;
    }
    if (isset($this->slotCache[$this->culture][$name]))
    {
      foreach ($this->slotCache[$this->culture][$name] as $permid => $slot)
      {  
        $results[$permid] = $slot;
      }
    }
    if ($new && (!$newFirst))
    {
      $results[$permidAndRank['permid']] = $new;
    }
    return $results;
  }

  /**
   * @param $areaInfos array
   * Iterates through areas, area versions and area version slots to locate the actual
   * current list of slots for each area name and arrange them in a convenient associative
   * array by culture, area name and permid. Used to implement getArea() and other methods
   * efficiently. Can also accept an array of areaInfo arrays obtained via array hydration,
   * in which case we take care of hydrating the slot objects here and skip hydrating
   * the intervening objects
   *
   * YOU MUST fetch the page with an appropriate query method such as retrieveBySlug(),
   * retrieveById, queryWithSlot or queryWithSlots, otherwise you will NOT get the 
   * right slots in the right order in the right culture for the right version. Especially
   * if your client is in the office for a demo
   */
  public function populateSlotCache($areaInfos = null)
  {
    // If we cheated on the hydration process then we'll be passed an
    // array of areaInfos explicitly and we must hydrate the slots. Otherwise
    // we have a perfectly normal Doctrine object on our hands
    if (is_null($areaInfos))
    {
      $areaInfos = $this->Areas;
    }
    if ($this->slotCache === false)
    {
      $this->slotCache = array();
      // We have $this->Areas courtesy of whatever query
      // fetched the page in the first place
      foreach ($areaInfos as $areaInfo)
      {
        $areaVersionInfo = $areaInfo['AreaVersions'][0];
        foreach ($areaVersionInfo['AreaVersionSlots'] as $areaVersionSlotInfo)
        {
          if (isset($areaVersionSlotInfo['Slot']))
          {
            $slotInfo = $areaVersionSlotInfo['Slot'];
            if (is_object($slotInfo))
            {
              // Make sure there actually is a slot already for this version, don't let a surprise in the db crash us
              if ($slotInfo->isNew())
              {
                continue;
              }
              $slot = $slotInfo;
            }
            else
            {
              $slotClass = $slotInfo['type'] . 'Slot';
              $slot = new $slotClass();
              $mediaItemInfos = $slotInfo['MediaItems'];
              unset($slotInfo['MediaItems']);
              $slot->hydrate($slotInfo);
              $slot->setClean();
              foreach ($mediaItemInfos as $mediaItemInfo)
              {
                $mediaItem = new aMediaItem();
                $mediaItem->hydrate($mediaItemInfo);
                $slot->MediaItems[] = $mediaItem;
              }
            }
            $this->slotCache[$areaInfo['culture']][$areaInfo['name']][$areaVersionSlotInfo['permid']] = $slot;
          }
          // foreach ($slot->MediaItems as $mediaItem)
          // {
          //   echo($mediaItem->id . ',');
          // }
        }
      }
    }
  }

  /**
   * Returns entity-escaped plaintext with newlines
   * @param mixed $areaname
   * @param mixed $word_limit
   * @return mixed
   */
  public function getAreaText($areaname, $word_limit = false)
  {
    $slots = $this->getSlotsByAreaName($areaname);
    $text = '';
    foreach ($slots as $slot)
    {
      if (strlen($text))
      {
        $text .= "\n\n";
      }
      $text .= $slot->getText();
    }
    if ($word_limit) {
      return aString::limitWords($text, $word_limit, array('append_ellipsis' => true));
    }
    else
    {
      return $text;      
    }
  }

  /**
   * DOCUMENT ME
   * @param mixed $areaname
   * @param mixed $word_limit
   * @return mixed
   */
  public function getAreaBasicHtml($areaname, $word_limit = false)
  {
    $slots = $this->getSlotsByAreaName($areaname);
    $text = '';
    foreach ($slots as $slot)
    {
      if (strlen($text))
      {
        // div might not be permitted in a lot of 'basic html'
        // contexts, but we do need some vertical break between
        // two slots to reasonably reproduce what
        // Apostrophe does with them
        $text .= '<br />';
      }
      $text .= $slot->getBasicHtml();
    }
    if ($word_limit) {
      return aHtml::limitWords($text, $word_limit, array('append_ellipsis' => true));
    }
    else
    {
      return $text;      
    }
  }

  /**
   * DOCUMENT ME
   * @param mixed $areaname
   * @param mixed $word_limit
   */
  public function getRichTextForArea($areaname, $word_limit = false)
  {
    $this->getAreaBasicHtml($areaname, $word_limit);
  }

  /**
   * DOCUMENT ME
   * @param mixed $name
   * @param mixed $first
   * @return mixed
   */
  public function getNextPermidAndRank($name, $first = false)
  {
    $query = Doctrine_Query::create()->
        select('max(s.permid) as m, ' 
          . ($first ? 'min' : 'max') . '(s.rank) as r')->
        from('aArea a')->
        leftJoin('a.AreaVersions v')->
        leftJoin('v.AreaVersionSlots s')->
        where('a.name = ? AND a.page_id = ?', array($name, $this->id));
    $result = $query->execute();
         
    if (isset($result[0]['m']))
    {
      $permid = $result[0]['m'] + 1;
    }
    else
    {
      $permid = 1;
    }
    // Negative ranks = perfectly fine and useful for
    // implementing "new slots on top"
    if (isset($result[0]['r']))
    {
      if ($first)
      {
        $rank = $result[0]['r'] - 1;
      }
      else
      {
        $rank = $result[0]['r'] + 1;
      }
    }
    else
    {
      $rank = 1;
    }
    return array(
      'permid' => $permid, 
      'rank' => $rank);
  }

  /**
   * DOCUMENT ME
   * @param mixed $type
   * @return mixed
   */
  public function createSlot($type)
  {
    $class = $type . "Slot";
    $slot = new $class;
    $slot->type = $type;
    return $slot;
  }

  /**
   * WARNING: You need to retrieve the slots properly before you can use this
   * reliably. That means using aPageTable::retrieveBySlugWithSlots() or
   * aPageTable::retrieveByIdWithSlots() or aPageTable::queryWithSlots() to retrieve
   * the page in the first place. (You can also use aPageTable::retrieveBySlugWithTitles()
   * to avoid loading other slots on the page, but only if you don't turn around and try
   * to use those other slots.)
   * Otherwise Doctrine will pull every slot by default, including old slots
   * in the history and slots in other languages, and they will not be in
   * the right order, especially if your client is in your office for a dmeo.
   * So heed this warning. Thanks.
   * @return mixed
   */
  public function getTitle()
  {
    $titleSlot = $this->getSlot('title');
    if ($titleSlot)
    {
      $result = $titleSlot->value;
    }
    else
    {
      $result = '';
    }
    $title = trim($result);
    if (!strlen($result))
    {
      // Don't break the UI, return something reasonable
      $slug = $this->slug;
      $title = substr(strrchr($slug, "/"), 1);
      if (!strlen($title))
      {
        if ($this->isNew())
        {
          $title = '';
        }
        else
        {
          $title = "Home";
        }
      }
    }
    // Title is a plaintext slot. Sometimes people let people edit it as such.
    // That can introduce link tags, or even paragraph tags if they allow it to be
    // edited as multiline (but we're mostly worried about the link tags that come
    // from the more reasonable single-line case)
    $title = strip_tags($title);
    return $title;
  }

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function getMetaDescription()
  {
    $metaDescriptionSlot = $this->getSlot('metaDescription');
    
    $result = '';
    if ($metaDescriptionSlot)
    {
      $result = $metaDescriptionSlot->value;
    }
    return trim($result);
  }

  /**
   * Changed in 1.5: returns a flat array, not an associative array indexed by version.
   * The latter was not very useful and made it difficult to pass through JSON
   * in a useful form
   * @param mixed $name
   * @param mixed $selectOptions
   * @param mixed $limit
   * @return mixed
   */
  public function getAreaVersions($name, $selectOptions = true, $limit = 10)
  {
    $q = Doctrine_Query::create()->
      from("aAreaVersion av")->
      leftJoin("av.Area a")->
      leftJoin("av.Author au")->
      where("a.page_id = ? AND a.name = ? AND a.culture = ?",
        array($this->id, $name, $this->culture))->
      orderBy("av.version desc");
    if(!is_null($limit))
      $q->limit($limit);
    $areaVersions = $q->execute();
    $versions = array();  
    foreach ($areaVersions as $areaVersion)
    {
      if ($selectOptions)
      {
        $versions[$areaVersion->version] = 
          $areaVersion->created_at . " " . ($areaVersion->Author ? 
              $areaVersion->Author->username : "NONE") . " " . $areaVersion->diff;
      }
      else
      {
        $versions[] =
          array("created_at" => $areaVersion->created_at, "author" => $areaVersion->Author ? $areaVersion->Author->username : "NONE", "diff" => $areaVersion->diff,
          "version" => $areaVersion['version']);
      }
    }
    return $versions;   
  }

  /**
   * DOCUMENT ME
   * @param mixed $name
   * @return mixed
   */
  public function getAreaCurrentVersion($name)
  {
    $area = Doctrine_Query::create()->
      from("aArea a")->
      where("a.page_id = ? AND a.name = ? AND a.culture = ?",
        array($this->id, $name, $this->culture))->
      fetchOne();
    if ($area)
    {
      return $area->latest_version;
    }
    return 0;
  }

  /**
   * This is not the most efficient way to learn about the child pages of the current page.
   * See getChildrenInfo. This method is now primarily for backwards compatibility and relatively rare cases where
   * you need a slot other than the title.
   * Returns an array even when there are zero children.
   * Who in the world wants to special case that as if it
   * were the end of the world?
   * @param mixed $livingOnly
   * @param mixed $withSlot
   * @return mixed
   */
  public function getChildren($livingOnly = true, $withSlot = 'title')
  {
    if ($this->childrenCache !== null)
    {
      if (($livingOnly === $this->childrenCacheLivingOnly) && ($this->childrenCacheSlot === $withSlot))
      {
        return $this->childrenCache;
      }
    }
    // TODO: consider whether it's possible to get the base query to
    // exclude archived children. That would result in multiple
    // calls to where(), but perhaps Doctrine can combine them for us.
    if ($withSlot !== false)
    {
      aPageTable::treeSlotOn($withSlot);      
    }
    $children = $this->getNode()->getChildren();
    
    if ($children === false)
    {
      $children = array();
    }
    
    if ($withSlot !== false)
    {
      aPageTable::treeSlotOff();
    }
    
    // Don't let Doctrine's clever reuse of objects prevent us from seeing
    // the results if we fetch a different slot this time... unless the child
    // is also the current page. In that case we assume that we have superior
    // data in the cache already (inclusive of all slots). Discarding that
    // was leading to disappearing data on emap
      
    $current = aTools::getCurrentPage();
    foreach ($children as $child)
    {
      if ($current && ($current->id === $child->id))
      {
        continue;
      }
      $child->clearSlotCache();
    }
    if ($children !== false)
    {
      $living = array();
      $dead = array();
      foreach ($children as $child)
      {
        if ($child->admin)
        {
          // Never show admin pages in navigation
          continue;
        }
        if ($child->archived)
        {
          $dead[] = $child;
        }
        else
        {
          $living[] = $child;
        }
      }
      if ($livingOnly)
      {
        $children = $living;
      }
      else
      {
        $children = array_merge($living, $dead);
      }
    }
    else
    {
      $children = array();
    }
    $this->childrenCache = $children;
    $this->childrenCacheLivingOnly = $livingOnly;
    $this->childrenCacheSlot = $withSlot;
    return $children;
  }

  /**
   * Optimized methods returning information about related pages.
   * All of these methods return an array of associative arrays, as follows:
   * array(
   * array('id' => page1id, 'title' => page1title, 'slug' => page1slug, 'view_is_secure' => bool, 'archived' => bool, 'level' => level),
   * array('id' => page2id, 'title' => page2title, 'slug' => page2slug, 'view_is_secure' => bool, 'archived' => bool, 'level' => level) ...
   * )
   * The getTreeInfo and getAccordionInfo methods return nested arrays. If a page has children that
   * are suitable to return, then the associative array for that page will have a 'children' key, and
   * the value will be an array of child pages, which may have children of their own. If a page has
   * no children there will not be a 'children' key (you may test isset($info['children'])).
   * To generate a URL for a page use: aTools::urlForPage($info['slug'])
   * @param mixed $includeSelf
   * @param mixed $livingOnly
   * @return mixed
   */
  public function getAncestorsInfo($includeSelf = false, $livingOnly = false)
  {
    return aPageTable::getAncestorsInfo(array('info' => $this->getInfo(), 'includeSelf' => $includeSelf, 'livingOnly' => $livingOnly));
  }

  // Careful, the cache must hold the entire path including the item itself, we lop off the last element
  // before returning in those cases where it is not wanted. Note that $livingOnly does NOT change the 'level'
  // field for each returned ancestor

  protected $ancestorsInfo = array();

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function getParentInfo()
  {
    return aPageTable::getParentInfo(array('info' => $this->getInfo()));
  }

  protected $peerInfo;

  /**
   * The $livingOnly flag is present for bc only and is ignored, we get what the current user can see
   * @param mixed $livingOnly
   * @return mixed
   */
  public function getPeerInfo($livingOnly = true)
  {
    return aPageTable::getPeerInfo(array('info' => $this->getInfo(), 'livingOnly' => $livingOnly));
  }

  /**
   * Sometimes it is useful to have an info structure describing a page object
   * (the aNavigation classes exploit this, so does the search index, which needs
   * to be able to determine privileges for a page with a minimum of overhead)
   * @return mixed
   */
  public function getInfo()
  {
    return array('id' => $this->id, 'title' => $this->getTitle(), 'slug' => $this->slug, 'view_is_secure' => $this->view_is_secure, 'view_guest' => $this->view_guest, 'engine' => $this->engine, 'view_admin_lock' => $this->view_admin_lock, 'edit_admin_lock' => $this->edit_admin_lock, 'archived' => $this->archived, 'admin' => $this->admin, 'level' => $this->level, 'lft' => $this->lft, 'rgt' => $this->rgt);
  }
  
  protected $childrenInfo;

  /**
   * DOCUMENT ME
   * @param mixed $livingOnly
   * @return mixed
   */
  public function getChildrenInfo($livingOnly = true)
  {
    return aPageTable::getChildrenInfo(array('info' => $this->getInfo(), 'livingOnly' => $livingOnly));
  }

  /**
   * TODO: migrate getTreeInfo and getAccordionInfo more fully to the table class level, with options arrays.
   * Then work on killing the old parameters to these methods in favor of an options array at this level too.
   * I would like to do this for 1.5 but we've addressed the most important use case at this point
   * (users should only see links they have the privileges to visit), so it will have to wait for 1.6
   * If $depth is null we get all of the descendants
   * The $livingOnly flag is present for bc only and is ignored, we get what the current user can see
   * @param mixed $livingOnly
   * @param mixed $depth
   * @return mixed
   */
  public function getTreeInfo($livingOnly = true, $depth = null)
  {
    // Recursively builds a page tree. If a page has children, the info array for that
    // page will have a 'children' element containing an array of info arrays for its
    // children, etc.
    
    // Efficiently fetches only to the appropriate depth

    // Sometimes trees will have enabled children of disabled parents. When
    // we don't want disabled pages, we have to exclude those pages too, so we'll
    // do the exclusion at a higher level, not in the SQL query

    $infos = $this->getDescendantsInfo(false, $depth);
    $offset = 0;
    $level = 0;

    $result = $this->getTreeInfoBody($this->lft, $this->rgt, $infos, $offset, $level + 1, $depth, $livingOnly);
		return $result;
  }

  /**
   * DOCUMENT ME
   * @param mixed $lft
   * @param mixed $rgt
   * @param mixed $infos
   * @param mixed $offset
   * @param mixed $level
   * @param mixed $depth
   * @param mixed $livingOnly
   * @return mixed
   */
  protected function getTreeInfoBody($lft, $rgt, $infos, &$offset, $level, $depth, $livingOnly)
  {
    $count = count($infos);
    $result = array();
    if ($depth === 0)
    {
      // Limit depth 
      return $result;
    }
    while ($offset < $count)
    {      
      $info = $infos[$offset];
      if (($info['lft'] <= $lft) || ($info['rgt'] >= $rgt))
      {
        break;
      }
      $offset++;
      $children = $this->getTreeInfoBody($info['lft'], $info['rgt'], $infos, $offset, $level + 1, isset($depth) ? ($depth - 1) : null, $livingOnly);
      if (count($children))
      {
        $info['children'] = $children;
      }
			// When we're only interested in "living" pages, we have to ignore both archived pages and
			// their descendants. This is tricky because getDescendantsInfo() is not tree-aware but does not
			// return archived parents of published children. So we have to manually ignore any grandkids that
			// show up where kids should be. Note that $level is relative to the root requested not the site root
      if ($livingOnly && ((isset($info['archived']) && $info['archived']) || ($info['level'] > ($this->level + $level))))
      {
        continue;
      }
      else
      {
        $result[] = $info;
      }
    }
    return $result;
  }

  /**
   * Accordion nav
   * Always starts with the children of the root and comes down to the level of this page's children,
   * listing peers of this page's ancestors at every level. That is:
   * Home
   * One
   * 1a
   * 1b
   * 1bx  <-- the current page
   * 1bxA
   * ibxB
   * 1c
   * Two
   * You can now specify the root slug, which defaults to the home page.
   * Note that children of Two, 1a, and 1c are NOT returned. Only the siblings of
   * the current page's ancestors, the current page and its siblings, and the immediate
   * children of the current page are returned. For a full tree use getTreeInfo().
   * The livingOnly flag is present for bc only and is ignored, we get what the current user can see
   * @param mixed $livingOnly
   * @param mixed $depth
   * @param mixed $root
   * @return mixed
   */
  public function getAccordionInfo($livingOnly = true, $depth = null, $root = '/')
  {
    // As far as I can tell there is no super-elegant, single-query way to do this
    // without fetching a lot of extra pages. So do a peer fetch at each level.
    
    // First build an array of arrays listing the peers at each level

    // If you have enabled children of archived ancestors and you don't
    // want the ancestors to show up, you probably shouldn't be using
    // an accordion contro. in the first place

    // We need all of the ancestors to build an accordion successfully, in particular
    // since we often want a hidden parent to be the root. Give more thought to whether 
    // we can do this just for the root
    $ancestors = aPageTable::getAncestorsInfo(array('info' => $this->getInfo(), 'ignore_permissions' => true));
    // Dump ancestors we don't care about
    $found = false;
    for ($i = 0; ($i < count($ancestors)); $i++)
    {
      if ($ancestors[$i]['slug'] === $root)
      {
        $rootLevel = $ancestors[$i]['level'];
        $ancestors = array_slice($ancestors, $i);
        $found = true;
        break;
      }
    }
    if (!$found)
    {
      // Active page is not a descendant of the root. Just return the children of the root.
      // This makes the accordion more useful when you are not yet under its root
      // I don't have a handy way to do this without cache issues in the table class yet so...
      // This is not a proper info structure but it will work for this job
      $rootInfo = Doctrine::getTable('aPage')->createQuery('p')->where('slug = ?', array($root))->execute(array(), Doctrine::HYDRATE_ARRAY);
      if (!count($rootInfo))
      {
        throw new sfException("Root page of accordion does not exist!");
      }
      $rootInfo = $rootInfo[0];
      return aPageTable::getChildrenInfo(array('info' => $rootInfo));
    }
    $result = array();
    foreach ($ancestors as $ancestor)
    {
      if (($ancestor['level'] > $rootLevel) && $livingOnly && ($ancestor['archived']))
      {
        continue;
      }
      $lineage[] = $ancestor['id'];
      if ($ancestor['level'] == $rootLevel)
      {
        $result[] = array($ancestor);
      }
      else
      {
        // TODO: this is inefficient, come up with a way to call getPeerInfo for an
        // alternate ID without fetching that entire page
        $peers = aPageTable::retrieveBySlug($ancestor['slug'])->getPeerInfo($livingOnly);
        $result[] = $peers;
      }
    }
    // Current page peers level
    $result[] = $this->getPeerInfo($livingOnly);
    $lineage[] = $this->id;
    // Current page children level
    $result[] = $this->getChildrenInfo($livingOnly);
    
    // Now fix it up to be a properly nested array like that
    // returned by getTreeInfo(). On each pass take a reference
    // to the child that will own the children of the next pass
    $accordion = $result[0][0];
    $current = &$accordion;
    for ($i = 0; ($i < (count($result) - 1)); $i++)
    {
      $current['children'] = $result[$i + 1];
      if ($i + 1 < count($lineage))
      {
        // We've already started returning the kids as a flat array so 
        // we need to scan for it unfortunately. This entire method could
        // use more attention to performance
        foreach ($current['children'] as &$child)
        {
          if ($child['id'] == $lineage[$i + 1])
          {
            $current = &$child;
            break;
          }
        }
      }
    }
    
    // Don't return the home page itself, start with the tabs.
    // This is consistent with getTreeInfo() which should simplify implementations.
    // It's easy to add the home page in at a higher level if desired.
    return $accordion['children'];
  }

  /**
   * Used by the reorganize feature. Return value is compatible with jstree.
   * See getTreeInfo for something more appropriate for front end navigation
   * @param mixed $livingOnly
   * @return mixed
   */
  public function getTreeJSONReady($livingOnly = true)
  {
    // Recursively builds a page tree ready to be JSON-encoded and sent to
    // the jsTree object (yes this is rather specific to jsTree for the model layer,
    // but this would be a reasonable input format for any JS tree implementation).
    
    // Sometimes trees will have enabled children of archived parents. When
    // we don't want disabled pages, we have to exclude those pages too, so we'll
    // do the exclusion at a higher level, not in the SQL query
    $infos = $this->getDescendantsInfo(false);
    $offset = 0;
    $level = 0;
    $tree = array("attributes" => array("id" => "tree-" . $this->id),
      "data" => $this->getTitle(),
      // This is sometimes useful in project level overrides and the extra info doesn't hurt
      "slug" => $this->getSlug(),
      "state" => 'open',
      "children" => $this->getTreeJSONReadyBody($this->lft, $this->rgt, $infos, $offset, $level + 1, $livingOnly)
    );
    if (!count($tree['children']))
    {
      unset($tree['children']);
    }
    else
    {
      $item['state'] = 'open';
    }
    return $tree;
  }

  /**
   * DOCUMENT ME
   * @param mixed $lft
   * @param mixed $rgt
   * @param mixed $infos
   * @param mixed $offset
   * @param mixed $level
   * @param mixed $livingOnly
   * @return mixed
   */
  protected function getTreeJSONReadyBody($lft, $rgt, $infos, &$offset, $level, $livingOnly)
  {
    $count = count($infos);
    $result = array();
    while ($offset < $count)
    {      
      $info = $infos[$offset];
      if (($info['lft'] <= $lft) || ($info['rgt'] >= $rgt))
      {
        break;
      }
      $offset++;
      $class = ($info['archived'])? 'archived' : 'alive';
      $class.= (!is_null($info['engine']))? ' engine-'.$info['engine'] : '';
      $item = array(
        "attributes" => array("id" => "tree-" . $info['id'], "class" => $class), 
        "data" => $info['title'],
        "slug" => $info['slug'],
        // Too many CSS problems with this '<span class="a-tree-title">' . $info['title'] . '<b class="a-tree-delete-btn">Delete</b></span>',
        "children" => $this->getTreeJSONReadyBody($info['lft'], $info['rgt'], $infos, $offset, $level + 1, $livingOnly)
      );
      if (!count($item['children']))
      {
        unset($item['children']);
      }
      else
      {
        $item['state'] = ($level < 2) ? "open" : "closed";
      }
      if ($livingOnly && isset($info['archived']) && $info['archived'])
      {
        // Skip it (and therefore its children as well) in the final result
      }
      else
      {
        $result[] = $item;
      }
    }
    return $result;
  }

  /**
   * Low level access to all info for all descendants. You probably don't want this. For an interface that
   * gives you back a hierarchy see getTreeInfo.
   * The $livingOnly option is present for bc only and is ignored (we look at what the current user can see)
   * @param mixed $livingOnly
   * @param mixed $depth
   * @return mixed
   */
  protected function getDescendantsInfo($livingOnly = true, $depth = null)
  {
    $where = '( p.lft > ' . $this->lft . ' AND p.rgt < ' . $this->rgt . ' )';
    if (isset($depth))
    {
      $where = '(' . $where . ' AND (p.level <= ' . ($this->level + $depth) . '))';
    }
    return $this->getPagesInfo($livingOnly, $where);
  }

  /**
   * This is the low level query method used to implement the above. You won't call this directly
   * unless you're implementing a new type of query for related pages.
   * The $livingOnly option is present for bc only and is ignored (we look at what the current user can see)
   * @param mixed $livingOnly
   * @param mixed $where
   * @param mixed $admin
   * @return mixed
   */
  protected function getPagesInfo($livingOnly = true, $where, $admin = false)
  {
    return aPageTable::getPagesInfo(array('culture' => $this->getCulture(), 'where' => $where, 'admin' => $admin));
  }

  /**
   * The $livingOnly option is present for bc only and is ignored (we look at what the current user can see)
   * @param mixed $livingOnly
   * @return mixed
   */
  public function hasChildren($livingOnly = true)
  {
    // not as inefficient as it looks because of the caching feature
    return (count($this->getChildren($livingOnly)) != 0);
  }

  /**
   * DOCUMENT ME
   * @param mixed $absolute
   * @return mixed
   */
  public function getUrl($absolute = true)
  {
    return aTools::urlForPage($this->getSlug(), $absolute);
  }

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function getAncestors()
  {
    // Home page has no ancestors; save a query on a popular page
    if ($this->level == 0)
    {
      return array();
    }
    if ($this->ancestorsCache !== false)
    {
      return $this->ancestorsCache;
    } 
    aPageTable::treeTitlesOn();
    $this->ancestorsCache = $this->getNode()->getAncestors();
    aPageTable::treeTitlesOff();
    if ($this->ancestorsCache === false)
    {
      // Empty lists are not evil!
      $this->ancestorsCache = array();
    }
    return $this->ancestorsCache;
  }

  /**
   * DOCUMENT ME
   * @param mixed $page
   * @return mixed
   */
  public function isEqualTo($page)
  {
    return ($page->getSlug() === $this->getSlug());
  }

  /**
   * DOCUMENT ME
   */
  public function begin()
  {
    $conn = Doctrine_Manager::connection();
    $conn->beginTransaction();
  }

  /**
   * DOCUMENT ME
   */
  public function end()
  {
    $conn = Doctrine_Manager::connection();
    $conn->commit();
  }

  /**
   * SAVE ANY CHANGES to the actual page object FIRST before you call this method.
   * 20090505: you must pass valid HTML text (i.e. pre-escaped entities)
   * @param mixed $title
   */
  public function setTitle($title)
  {
    $slot = $this->createSlot('aText');
    $slot->value = $title;
    $slot->save();
    $this->newAreaVersion('title', 'update', 
      array(
        'permid' => 1, 
        'slot' => $slot));
  }

  /**
   * DOCUMENT ME
   * @param mixed $description
   */
  public function setMetaDescription($description)
  {
    $slot = $this->createSlot('aText');
    $slot->value = $description;
    $slot->save();
    
    $this->newAreaVersion('metaDescription', 'update',
      array(
        'permid' => 1,
        'slot' => $slot));
    
  }

  /**
   * SAVE ANY CHANGES to the actual page object FIRST before you call this method.
   * @param mixed $name
   * @param mixed $action
   * @param mixed $params
   */
  public function newAreaVersion($name, $action, $params = false)
  {
    // Lock this page while adding a new version to it. This prevents race conditions with the
    // assignment of new permids and ranks (fixes #306)
    aTools::lock('page_' . $this->id);
    
    $diff = '';
    if ($params === false)
    {
      $params = array();
    }
    $this->begin();
    // We use the slots already queried as a basis for the new version,
    // because that makes rollback easy to implement etc. But we
    // MUST fetch the latest copy of the area object to make sure
    // we don't create duplicate versions.

    // When we're adding a new slot to an area we need to make sure it
    // it is first in the hash so it gets ranked first
    if ($action === 'add')
    {
      // New: support for specifying whether the new slot is at top or bottom of the area
      $top = (!isset($params['top'])) || $params['top'];
      $diff = (isset($params['slot']))? "<strong>" . aString::limitCharacters($params['slot']->getSearchText(), 20) . "</strong>" : '';
      $newSlots = $this->getSlotsByAreaName($name, $params['slot'], $top);
    }
    else
    {
      $newSlots = $this->getSlotsByAreaName($name);
    }
    $area = aAreaTable::retrieveOrCreateByPageIdAndName(
      $this->id,
      $name);
    if (!$area->id)
    {
      // We need an ID established
      $area->save();
    }
    $areaVersion = new aAreaVersion();
    $areaVersion->area_id = $area->id;
    $areaVersion->version = $area->latest_version + 1;
    // Don't crash on an anon edit, such as an edit made by a task
    if (sfContext::hasInstance() && sfContext::getInstance()->getUser()->getGuardUser())
    {
      $areaVersion->author_id = 
        sfContext::getInstance()->getUser()->getGuardUser()->getId();
    }
    if ($action === 'delete')
    {
      if (isset($newSlots[$params['permid']]))
      {
        $diff = '<strike>' . aString::limitCharacters($newSlots[$params['permid']]->getSearchText(), 20) . '</strike>';
        unset($newSlots[$params['permid']]);
      }
    }
    elseif ($action === 'update')
    {
      $oldText = '';
      if (isset($newSlots[$params['permid']]))
      {
        $oldText = $newSlots[$params['permid']]->getSearchText(); 
      }
      $newText = (isset($params['slot']))? $params['slot']->getSearchText() : '';
      $fullDiff = aString::diff($oldText, $newText);
      $diff = '';
      if (!empty($fullDiff['onlyin1']))
      {
        $diff .= '<strike>' . aString::limitCharacters($fullDiff['onlyin1'][0], 20) . '</strike>';
      }
      if (!empty($fullDiff['onlyin2']))
      {
        $diff .= '<strong>' . aString::limitCharacters($fullDiff['onlyin2'][0], 20) . '</strong>';
      }
      $newSlots[$params['permid']] = $params['slot']; 
    }
    elseif ($action === 'variant')
    {
      $newSlot = $newSlots[$params['permid']]->copy();
      if (!$newSlot)
      {
        throw new sfException('Slot does not exist');
      }
      $variants = sfConfig::get('app_a_slot_variants');
      if (!isset($variants[$newSlot->type][$params['variant']]))
      {
        throw new sfException('Variant not defined for this slot type');
      }
      $newSlot->variant = $params['variant'];
      // Must have an id before we can make an AreaVersionSlot referencing it
      $newSlot->save();
      $newSlots[$params['permid']] = $newSlot;
      $diff = $newSlot->variant;
    }
    elseif ($action === 'add')
    {
      // We took care of this in the getArea call
    }
    elseif ($action === 'sort')
    {
      $diff = '[Reordered slots]';
      $newerSlots = array();
      foreach ($params['permids'] as $permid)
      {
        $newerSlots[$permid] = $newSlots[$permid];
      }
      $newSlots = $newerSlots;
    }
    elseif ($action === 'revert')
    {
      // TODO: actually represent the changes carried out by the reversion
      // in the diff. That's rather expensive because many slots in the area
      // may have changed all at once.
      $diff = '[Reverted to older version]';
      # We just want whatever is in the slot cache copied to a new version
    }
    
    $areaVersion->diff = $diff;
    $areaVersion->save();

    $rank = 1;
    foreach ($newSlots as $permid => $slot)
    {
      // After unset, foreach shows keys but has null values
      if (!$slot)
      {
        continue;
      }
      $areaVersionSlot = new aAreaVersionSlot();
      $areaVersionSlot->slot_id = $slot->id;
      $areaVersionSlot->permid = $permid;
      $areaVersionSlot->area_version_id = $areaVersion->id;
      $areaVersionSlot->rank = $rank++;
      $areaVersionSlot->save();
    }
    $area->latest_version++;
    $area->save();
    $this->requestSearchUpdate();
    $this->end();
    aTools::unlock();
  }

  /**
   * DOCUMENT ME
   * @param mixed $allcultures
   */
  public function requestSearchUpdate($allcultures = false)
  {
    // we want to build an array so we can map the Lucene update across all elements
    $aPages = array($this);
    if ($allcultures)
    {
      $aPages = array();
      
      $cultures = array();

      $page = Doctrine::getTable('aPage')
        ->createQuery('p')
        ->where('p.id = ?', $this->id)
        ->leftJoin('p.Areas a')
        ->fetchOne(array(), Doctrine::HYDRATE_ARRAY);
 
      foreach ($page['Areas'] as $area)
      {
        $cultures[$area['culture']] = true; 
      }

      $cultures = array_keys($cultures);

      foreach ($cultures as $culture)
      {
        $aPages[] = aPageTable::retrieveByIdWithSlots($this->id, $culture);
      }
    }
    
    // save a variable for the update function
    if (sfConfig::get('app_a_defer_search_updates', false))
    {
      // Deferred updates are sometimes nice for performance...
      foreach ($aPages as $page)
      {
        aLuceneUpdateTable::requestUpdate($page);
      }
    }
    else
    {
      // ... But the average developer hates cron.
       
      // Without this the changes we just made aren't visible to getSearchText,
      // we need to trigger a thorough recaching
    
      foreach ($aPages as $page)
      {
        // I swear to you that this used to update the same object due to Doctrine's
        // internal caching, but guess what, it doesn't anymore. So make sure we call
        // updateLuceneIndex on the returned object 
        $newPage = aPageTable::retrieveByIdWithSlots($page->id);
        $newPage->updateLuceneIndex();
      }
    }
  }

  /**
   * DOCUMENT ME
   */
  public function clearSlotCache()
  {
    $this->slotCache = false;
  }

  /**
   * DOCUMENT ME
   * @param mixed $privilege
   * @return mixed
   */
  public function getAccessesById($privilege)
  {
    $candidateGroup = sfConfig::get('app_a_' . $privilege . '_candidate_group', false);
    $sufficientGroup = sfConfig::get('app_a_' . $privilege . '_sufficient_group', false);
    $query = Doctrine_Query::create();
    $query->from("sfGuardUser u");
    $withClauses = array();
    $withParameters = array();
    if ($candidateGroup)
    {
      $candidateGroup = Doctrine::getTable('sfGuardGroup')->findOneByName($candidateGroup);
      if (!$candidateGroup)
      {
        throw new Exception("Candidate group for $privilege was set but does not exist");
      }
      $withClauses[] = "g.id = ?";
      $withParameters[] = $candidateGroup->id;
    }
    if ($sufficientGroup)
    {
      $sufficientGroup = Doctrine::getTable('sfGuardGroup')->findOneByName($sufficientGroup);
      if (!$sufficientGroup)
      {
        throw new Exception("Sufficient group for $privilege was set but does not exist");
      }
      $withClauses[] = "g.id = ?";
      $withParameters[] = $sufficientGroup->id;
    }
    if (count($withClauses))
    {
      $query->innerJoin("u.Groups g with " . implode(" OR ", $withClauses),
        $withParameters);
    } 
    $query->orderBy("u.username asc");
    $allResults = $query->execute();
    $all = array();
    $sufficient = array();
    foreach ($allResults as $actor)
    {
      $all[$actor->id] = $actor->username;
      if ($sufficientGroup && ($actor->hasGroup($sufficientGroup->getName())))
      {
        $sufficient[] = $actor->id;
      }
    }
    $query = Doctrine_Query::create();
    $query->from("sfGuardUser u");
    $ancestors = $this->getAncestors();
    $ancestorIds = array();
    foreach ($ancestors as $ancestor)
    {
      $ancestorIds[] = $ancestor->id;
    }
    $ancestorIds[] = $this->id;
    $query->innerJoin("u.Accesses a with a.page_id IN (" .
      implode(",", $ancestorIds) . ") and a.privilege = ?", 
      array($privilege));
    $query->orderBy("u.username asc");
    $selectedResults = $query->execute();
    $selected = array();
    $inherited = array();
    $found = array();
    foreach ($selectedResults as $user)
    {
      foreach ($user->Accesses as $access)
      {
        if (!isset($found[$user->id]))
        {
          if ($access->page_id !== $this->id)
          {
            $inherited[] = $user->id;
            $found[$user->id] = true;
          }
          else
          {
            $selected[] = $user->id;
            $found[$user->id] = true;
          }
        }
      }
    }
    return array($all, $selected, $inherited, $sufficient);
  }

  /**
   * DOCUMENT ME
   * @param mixed $privilege
   * @param mixed $ids
   */
  public function setAccessesById($privilege, $ids)
  {
    // Could probably be more elegant using Doctrine collections
    $query = Doctrine_Query::create();
    // Make sure we select() only a.* so that we don't wind up
    // reloading the page object and causing problems in updateObject().
    $query->select('a.*')
      ->from('aAccess a')
      ->innerJoin('a.Page p')
      ->where('a.privilege = ? AND p.id = ?', array($privilege, $this->id));
    $accesses = $query->execute();
    foreach ($accesses as $access)
    {
      if ($access->privilege === $privilege)
      {
        $access->delete();
      }
    }
    foreach ($ids as $id)
    {
      $access = new aAccess();
      $access->user_id = $id;
      $access->privilege = $privilege;
      $access->page_id = $this->id;
      $access->save();
    }
  }

  /**
   * DOCUMENT ME
   * @param mixed $privilege
   * @return mixed
   */
  public function getGroupAccessesById($privilege)
  {
    $query = Doctrine_Query::create();
    $query->from("sfGuardGroup g");
    // Don't give this permission to the admin or guest groups. That way they don't become
    // candidates to receive page editing permissions (admin doesn't need them and guest
    // should never have them). Don't give it to editor either, since that defeats the purpose
    // of having a group of people who can be granted permissions individually
    $query->innerJoin('g.Permissions p WITH p.name = ?', sfConfig::get('app_a_group_editor_permission', 'editor'));
    $query->orderBy("g.name asc");
    $allResults = $query->execute();
    $all = array();
    foreach ($allResults as $actor)
    {
      $all[$actor->id] = $actor->name;
    }
    $query = Doctrine_Query::create();
    $query->from("sfGuardGroup g");
    $ancestors = $this->getAncestors();
    $ancestorIds = array();
    foreach ($ancestors as $ancestor)
    {
      $ancestorIds[] = $ancestor->id;
    }
    $ancestorIds[] = $this->id;
    $query->innerJoin("g.GroupAccesses a with a.page_id IN (" .
      implode(",", $ancestorIds) . ") and a.privilege = ?", 
      array($privilege));
    $query->orderBy("g.name asc");
    $selectedResults = $query->execute();
    $selected = array();
    $inherited = array();
    $found = array();
    foreach ($selectedResults as $group)
    {
      foreach ($group->Accesses as $access)
      {
        if (!isset($found[$group->id]))
        {
          if ($access->page_id !== $this->id)
          {
            $inherited[] = $group->id;
            $found[$group->id] = true;
          }
          else
          {
            $selected[] = $group->id;
            $found[$group->id] = true;
          }
        }
      }
    }
    return array($all, $selected, $inherited);
  }

  /**
   * DOCUMENT ME
   * @param mixed $privilege
   * @param mixed $ids
   */
  public function setGroupAccessesById($privilege, $ids)
  {
    // Could probably be more elegant using Doctrine collections
    $query = Doctrine_Query::create();
    // Make sure we select() only a.* so that we don't wind up
    // reloading the page object and causing problems in updateObject().
    $query->select('a.*')
      ->from('aGroupAccess a')
      ->innerJoin('a.Page p')
      ->where('a.privilege = ? AND p.id = ?', array($privilege, $this->id));
    $accesses = $query->execute();
    foreach ($accesses as $access)
    {
      if ($access->privilege === $privilege)
      {
        $access->delete();
      }
    }
    foreach ($ids as $id)
    {
      $access = new aGroupAccess();
      $access->group_id = $id;
      $access->privilege = $privilege;
      $access->page_id = $this->id;
      $access->save();
    }
  }

  /**
   * The parent object comes back with a populated title slot.
   * The other slots are NOT populated for performance reasons
   * (is there a scenario where this would be a problem?)
   * @param mixed $with
   * @return mixed
   */
  public function getParent($with = false)
  {
    if ($this->parentCache === false)
    {
      aPageTable::treeTitlesOn();
      $this->parentCache = $this->getNode()->getParent();
      aPageTable::treeTitlesOff();
    }
    return $this->parentCache;
  }

  /**
   * DOCUMENT ME
   * @param Doctrine_Connection $conn
   * @return mixed
   */
  public function delete(Doctrine_Connection $conn = null)
  {
    // TODO: must delete outstanding indexing requests here
    return aZendSearch::deleteFromDoctrineAndLucene($this, null, $conn);
  }

  /**
   * DOCUMENT ME
   * @param Doctrine_Connection $conn
   * @return mixed
   */
  public function doctrineDelete(Doctrine_Connection $conn)
  {
    return parent::delete($conn);
  }

  /**
   * DOCUMENT ME
   * @param Doctrine_Connection $conn
   * @return mixed
   */
  public function save(Doctrine_Connection $conn = null)
  {
    $result = parent::save($conn);
    $this->requestSearchUpdate(true);
    return $result;
  }

  /**
   * DOCUMENT ME
   * @param Doctrine_Connection $conn
   * @return mixed
   */
  public function doctrineSave(Doctrine_Connection $conn)
  {
    return parent::save($conn);
  }

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function updateLuceneIndex()
  {
    if ($this->getAdmin())
    {
      // Never index admin pages, that goes against the spirit of 
      // keeping them completely out of navigation, they are not
      // a place for content in the normal sense, they are engines
      // for administrative purposes
      return;
    }
    $title = $this->getTitle();
    $engine = $this->getEngine();
    $summary = $this->getSearchSummary();
    $text = $this->getSearchText();
    $tags = implode(',', $this->getTags());
    $categories = array();
    $categoryObjects = $this->getCategories();
    foreach ($categoryObjects as $category)
    {
      $categories[] = $category->getName();
    }
    $categories = implode(',', $categories);
    $metaDescription = $this->getMetaDescription();
    $slug = $this->getSlug();
    $info = $this->getInfo();
    // Already separate fields, so don't store them twice.
    unset($info['title'], $info['engine']);
    $tags = $this->getTags();
    $args = array('object' => $this,
      'indexed' => array('text' => $text, 'slug' => $slug, 'title' => $title, 'tags' => implode(', ', $tags), 'categories' => $categories, 'metadescription' => $metaDescription, 'engine' => $engine),
      'culture' => $this->getCulture(),
      // 1.5: always store fields under a name different from that used to index them.
      // Otherwise the storage overrides the indexing
      'stored' => array(
        'title_stored' => $title,
        'summary_stored' => $summary,
        'slug_stored' => $slug,
        // Nulls don't store well in Lucene
        'engine_stored' => strlen($engine) ? $engine : '',
        'info_stored' => serialize($info)),
      'boosts' => array('tags' => 2.0, 'metadescription' => 1.2, 'title' => 3.0),
      'keywords' => array(
        // We index the publication timestamp as a string consisting solely of digits. That allows
        // us to use Zend Lucene's TO construct to look at items published from now until eternity
        'published_at' => preg_replace('/[^\d]/', '', $this->published_at)
      ));
    if (strlen($engine))
    {
      $helperClass = $engine . 'SearchHelper';
      if (class_exists($helperClass))
      {
        $searchHelper = new $helperClass;
        $args = $searchHelper->filterUpdateLuceneIndex($args);
      }
    }

    // If a filter returns false, it might be associated with a missing event.
    // don't index
    if (is_array($args))
    {
      aZendSearch::updateLuceneIndex($args);
    }
  }

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function getSearchSummary()
  {
    return aString::limitWords($this->getSearchText(false), sfConfig::get('app_a_search_summary_wordcount', 50), "...");
  }

  /**
   * DOCUMENT ME
   * @param mixed $withTitle
   * @return mixed
   */
  public function getSearchText($withTitle = true)
  {
    $text = "";
    $this->populateSlotCache();
    if (isset($this->slotCache[$this->culture]))
    {
      foreach ($this->slotCache[$this->culture] as $name => $area)
      {
        if (!$withTitle)
        {
          if ($name === 'title')
          {
            continue;
          }
        }
        foreach ($area as $permid => $slot)
        {
          $text .= $slot->getSearchText() . "\n";
        }
      }
    }
    return $text;
  }

  /**
   * Pages can contain slots for all cultures, but this returns the
   * culture associated with the slots that were retrieved with
   * the page in this particular case.
   * @return mixed
   */
  public function getCulture()
  {
    return $this->culture;
  }

  /**
   * You don't call this ordinarily. It's part of the implementation of
   * fetching a page along with slots for a particualr culture.
   * @param mixed $culture
   */
  public function setCulture($culture)
  {
    $this->culture = $culture;
  }

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function getPeersAsOptionsArray()
  {
    $peers = array();
    $parent = $this->getParent();
    if (!$parent)
    {
      return $peers;
    }
    $children = $parent->getChildren();
    foreach ($children as $child)
    {
      if ($child->id === $this->id)
      {
        continue;
      }
      $peers[$child->id] = $child->getTitle();
    }
    return $peers;
  }

  /**
   * Fetch an array of information about categories related to this page. If the page is restricted by
   * category then only those categories are candidates for inclusion, otherwise any category might be
   * included in the results. The results are further filtered by whether any objects (or any objects
   * of the specified model class, if not null) are actually associated with those categories. An
   * a.get_count_by_category event is posted to determine the overall item counts by model class
   * for each category in an extensible way. The result is an associative array by model class,
   * the values of which are associative arrays with a single "counts" key, the value of
   * which is an associative array by category id of category information including name and
   * count keys
   * @param mixed $class
   * @return array
   */
  public function getCategoriesInfo($class = null)
  {

    $event = new sfEvent(null, 'a.get_count_by_category');
    sfContext::getInstance()->getEventDispatcher()->filter($event, array());
    $counts = $event->getReturnValue();

    $fcounts = array();
    
    $categories = $this->getCategories();
    if (!count($categories))
    {
      $categories = Doctrine::getTable('aCategory')->findAll();
    }
    $ids = aArray::listToHashById($categories);
    foreach ($counts as $cclass => $countsInfo)
    {
      $fcountsInfo = $countsInfo;
      foreach ($countsInfo['counts'] as $id => $info)
      {
        if (!isset($ids[$id]))
        {
          unset($fcountsInfo['counts'][$id]);
        }
      }
      $fcounts[$cclass] = $fcountsInfo;
    }
    if (!is_null($class))
    {
      if (isset($fcounts[$class]))
      {
        return $fcounts[$class];
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return $fcounts;
    }
  }

  /**
   * DOCUMENT ME
   * @param mixed $title
   * @return mixed
   */
  public function updateLastSlugComponent($title)
  {
    if ($this->slug === '/')
    {
      // We never update the home page slug
      return;
    }
    if ($this->getCulture() !== sfConfig::get('sf_default_culture'))
    {
      // Retitling a page in a culture other than the default does not
      // change the page slug
      return;
    }
    $component = aTools::slugify($title, false);
    $path = $this->slug;
    if (function_exists('mb_strrpos'))
    {
      $slash = mb_strrpos($path, '/');
      $newPath = mb_substr($path, 0, $slash + 1) . $component;
    }
    else
    {
      $slash = strrpos($path, '/');
      $newPath = substr($path, 0, $slash + 1) . $component;
    }
    if ($path === $newPath)
    {
      return;
    }
    $this->slug = $newPath;
    $this->save();
    Doctrine::getTable('aRedirect')->update($path, $this);
    $children = $this->getChildren();
    foreach ($children as $child)
    {
      $child->updateParentSlug($path, $newPath);
    }
  }

  /**
   * Update your slug based on your current parent's slug - no discussion or debate permitted.
   * Reorganize uses this. CAN be called when the parent is root, so be careful not to
   * set a double slash as a prefix
   */
  public function forceSlugFromParent()
  {
    $pslug = $this->getNode()->getParent()->slug;
    if ($pslug === '/')
    {
      $pslug = '';
    }
    if (function_exists('mb_substr'))
    {
      $slash = mb_strrpos($this->slug, '/');
      $newSlug = $pslug . mb_substr($this->slug, $slash);
    }
    else
    {
      $slash = strrpos($this->slug, '/');
      $newSlug = $pslug . substr($this->slug, $slash);      
    }
    if ($this->slug !== $newSlug)
    {
      Doctrine::getTable('aRedirect')->update($this->slug, $this);
      $this->slug = $newSlug;
      $this->save();
      $children = $this->getChildren();
      foreach ($children as $child)
      {
        $child->forceSlugFromParent();
      }
    }
  }

  /**
   * The parent's slug has changed (it is still the same parent). This is just an FYI - pges whose slugs
   * already diverge from the parent don't have to update their slugs too. Should never be called
   * when the parent is root
   * @param mixed $old
   * @param mixed $new
   * @return mixed
   */
  public function updateParentSlug($old, $new)
  {
    if ($old === '/')
    {
      throw new sfException("You can't change the slug of the root page, why are we here?");
    }
    // Make sure this page's slug is actually prefixed by its parent's slug followed
    // by a /. If not, it has already been customized and should not get uncustomized
    // just because somebody edited the title or slug of the parent
    $slug = $this->slug;
    $old .= '/';
    if (function_exists('mb_substr'))
    {
      $stem = mb_substr($slug, 0, mb_strlen($old));
      if ($stem !== $old)
      {
        return;
      }
      $slash = mb_strrpos($slug, '/');
      $newSlug = $new . mb_substr($slug, $slash);
    }
    else
    {
      $stem = substr($slug, 0, strlen($old));
      if ($stem !== $old)
      {
        return;
      }
      $slash = strrpos($slug, '/');
      $newSlug = $new . substr($slug, $slash);
    }
    
    if ($slug !== $newSlug)
    {
      $this->slug = $newSlug;
      Doctrine::getTable('aRedirect')->update($slug, $this);
      $this->save();
      $children = $this->getChildren();
      foreach ($children as $child)
      {
        $child->updateParentSlug($slug, $newSlug);
      }
    }
  }  
  
  // We may need this before we're done
  // protected function str_replace($old, $new, $content)
  // {
  //   if (function_exists('mb_strpos'))
  //   {
  //     $at = 0;
  //     while (($at = mb_strpos($content, $old, $at)) !== false)
  //     {
  //       $content = mb_substr($content, 0, $at) . $new . mb_substr($content, $at + mb_strlen($old));
  //       $at = $at + strlen($old);
  //     }
  //   }
  // }
}
